
// -----------------------------------------------------------------------
//  Imprime o c๓digo fonte do Analisador Sintแtico
// -----------------------------------------------------------------------

#ifndef IMPRIME_ANALISADOR_SINTATICO
#define IMPRIME_ANALISADOR_SINTATICO


#include <string>
#include "GeradorArquivoFacade.h"
#include "../util/Constantes.h"
#include "../util/Mensagem.h"

//-----------------------------------------------------------------------------
// Metodo que gera o arquivo do Analisador Sintatico
//-----------------------------------------------------------------------------
void GeradorArquivoFacade::geraArquivoAnalisadorSintatico() {
	// Verifica abertura de arquivo
	FILE *arq_c, *arq_h;
    if((arq_c=fopen(nome_sin_c,"wt"))==NULL) Mensagem::falha(CRIACAO_ARQ,nome_sin_c);
    if((arq_h=fopen(nome_sin_h,"wt"))==NULL) Mensagem::falha(CRIACAO_ARQ,nome_sin_h);

	// Gera arquivo .h do parser
	std::string fonte =
	"\n"
	"\n//---------------------------------------------------------------------------"
	"\n#ifndef AnalisadorSintaticoH"
	"\n#define AnalisadorSintaticoH"
	"\n//---------------------------------------------------------------------------"
	"\n"
	"\n#include <stack>"
	"\n#include <list>"
	"\n#include <string>"
	"\n#include \"AnalisadorLexico.h\""
	"\n"
	"\n//------------------------------------------------------------------------------"
	"\n// Classe que implementa o analisador sintแtico do compilador"
	"\n//------------------------------------------------------------------------------"
	"\nclass AnalisadorSintatico {"
	"\n"
	"\nprivate:"
	"\n	std::list <int> listaAtributos ;         // Guarda os atributos l้xicos para a anแlise semโntica"
	"\n	std::stack<int> pilhaProducoesBottomUp ; // Pilha que guarda as producoes na a็ใo de reduzir"
	"\n	std::stack<int> pilhaProducoesTopDown ;  // Pilha que guarda a sequencia de producoes chamadas no semโntico"
	"\n	std::string msgErro ;"
	"\n"
	"\n	// Fun็๕es auxiliares"
	"\n	void limpaVariaveis() ;"
	"\n	void transforma_producoes_analisador_semantico(int topo) ;"
	"\n	int determina_desvio(int &estado,int &nao_terminal) ;"
	"\n	void trata_erro(int &tipo,int &estado, Token tokenCorrente) ;"
	"\n"
	"\npublic:"
	"\n	//------------------------------------------------------------------------------"
	"\n	// Realiza a anแlise sintแtica"
	"\n	//------------------------------------------------------------------------------"
	"\n	void executa(std::string codigoFonte);"
	"\n"
	"\n	//-----------------------------------------------------------------"
	"\n	// Recupera a pilha de producoes seguida pela analise sintแtica"
	"\n	//-----------------------------------------------------------------"
	"\n	std::stack<int> getPilhaProducoesAnaliseSintatica() { return this->pilhaProducoesTopDown ; }"
	"\n"
	"\n	//---------------------------------------------------------------------"
	"\n	// Recupera a lista de atributos obtidos durante a anแlise l้xica"
	"\n	//---------------------------------------------------------------------"
	"\n	std::list<int> getListaAtributosAnaliseLexica() { return this->listaAtributos ; }"
	"\n"
	"\n	//------------------------------------------------------------------------------"
	"\n	// Tratamento de erros"
	"\n	//------------------------------------------------------------------------------"
	"\n	std::string getMsgErroSintatico() { return msgErro; }"
	"\n	bool encontrouErro() const { return msgErro != \"\"; };"
	"\n} ;"
	"\n"
	"\n"
	"\n//---------------------------------------------------------------------------"
	"\n"
	"\n#endif"
	"\n";
	fputs(fonte.c_str(), arq_h);

	// Gera arquivo .cpp do parser
	fonte =
	"\n/* -----------------------------------------------------------------------*"
	"\n * Analisador sintatico gerado pelo FACC 3.0.0                            *"
	"\n *                                                                        *"
	"\n *  Autores  : Edward Lucio Vieira Borba                                  *"
	"\n *             Claudio Vasconcelos Dobbin                                 *"
	"\n *             Luiz Reginaldo Almeida Fleury Curado                       *"
	"\n *                                                                        *"
	"\n *       Este software nao deve ser usado para fins comerciais sem acordo *"
	"\n *  previo com os autores.                                                *"
	"\n * -----------------------------------------------------------------------*"
	"\n *  A fun็ใo anasin faz a anแlise sintแtica. O analisador sintแtico usa o"
	"\n *  analisador l้xico, chamando o m้todo proxToken() para recuperar o pr๓ximo"
	"\n *  token do c๓digo fonte."
	"\n * -----------------------------------------------------------------------*/"
	"\n"
	"\n#include \"TabelaAnalisadorSintatico.h\" // Tabela do parser gerado pelo FACC"
	"\n#include \"AnalisadorSintatico.h\""
	"\n#include <stdlib.h>"
	"\n"
	"\n//------------------------------------------------------------------------------"
	"\n// A็๕es assumidas pelo analisador sintแtico"
	"\n//------------------------------------------------------------------------------"
	"\n#define ACAO_EMPILHAR(x)(x>2000)"
	"\n#define ACAO_REDUZIR(x) ((x>1000)&&(x<2000))"
	"\n#define ACAO_ACEITAR    1000"
	"\n#define ACAO_ERRO(x)    (x<1000)"
	"\n#define ACAO_FALHA(x)   (x==-1)"
	"\n"
	"\n//------------------------------------------------------------------------------"
	"\n/* M้todo que efetua a Anแlise Sintแtica do tipo Empilhar-Reduzir  */"
	"\n//------------------------------------------------------------------------------"
	"\nvoid AnalisadorSintatico::executa(std::string codigoFonte) { // retorna 0 se ok, 1 se deu erro"
	"\n"
	"\n  // Inicializa o analisador sintแtico"
	"\n  limpaVariaveis() ;"
	"\n"
	"\n  // Inicio da anแlise sintแtica de empilhar e reduzir - empilha o estado zero"
	"\n  std::stack<int> pilhaEstados ;"
	"\n  pilhaEstados.push(0);"
	"\n"
	"\n  // Inicializa o analisador lexico, recupera o primeiro token do codigo fonte"
	"\n  AnalisadorLexico lex(codigoFonte) ;"
	"\n  Token tokenCorrente = lex.proxToken() ;"
	"\n"
	"\n  // Se foi gerado um erro lexico, guarda a mensagem de erro"
	"\n  if ( lex.encontrouErro() ) {"
	"\n      msgErro = lex.getMsgErro();"
	"\n      return ;"
	"\n  }"
	"\n"
	"\n  // Se nใo foi gerado um erro l้xico, guarda o atributo do token, se ele tiver"
	"\n  if(TabelaAnalisadorSintatico::isTermAtrib(tokenCorrente.getValor() -1) == TRUE) {"
	"\n      listaAtributos.push_back( tokenCorrente.getAtributo() );"
	"\n  }"
	"\n"
	"\n  // Loop: Consulta a tabela sintแtica, tomando o estado no topo da pilha de estados e o token corrente."
	"\n  int acaoAnalisador;"
	"\n  while (( (acaoAnalisador = TabelaAnalisadorSintatico::getAcao(pilhaEstados.top(),tokenCorrente.getValor() - 1)) != ACAO_ACEITAR )) {"
	"\n"
	"\n     //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n     // 1) Se a a็ใo for falhar...จ"
	"\n     //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n	 if( ACAO_FALHA(acaoAnalisador) ) {"
	"\n	     msgErro = \"Erro na anแlise sintแtica: Tabela de a็ใo inconsistente\" ;"
	"\n         break;"
	"\n	 }"
	"\n"
	"\n	 //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n	 // 2) Se a a็ใo for erro..."
	"\n	 //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n	 else if( ACAO_ERRO(acaoAnalisador) ) {"
	"\n	    trata_erro(acaoAnalisador, pilhaEstados.top(), tokenCorrente);"
	"\n        break;"
	"\n"
	"\n     //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n     // 3) Se a a็ใo for reduzir por alguma producao..."
	"\n     //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n	 } else if( ACAO_REDUZIR(acaoAnalisador) ) {"
	"\n	    int producao = acaoAnalisador - 1000;"
	"\n"
	"\n	    // Remove |B| estados da pilha de estados, onde |B| ้ o tamanho do lado direito da producao (handle)"
	"\n	    for( int i=0; i < TabelaAnalisadorSintatico::getNroDireita(producao -1); i++) {"
	"\n	    	pilhaEstados.pop();"
	"\n	    }"
	"\n"
	"\n	    // Seja es o estado ao topo da pilha, A o nใo-terminal เ esquerda na produ็ใo sendo analisada"
	"\n	    // Usa es e A para determinar e empilhar o estado correspondente a desvio( A, es )"
	"\n	    int nao_terminal = TabelaAnalisadorSintatico::getNTermEsquerda(producao-1);"
	"\n	    pilhaEstados.push( determina_desvio(pilhaEstados.top(), nao_terminal) );"
	"\n"
	"\n	    // Guarda a producao na pilha de producoes"
	"\n	    pilhaProducoesBottomUp.push(producao);"
	"\n"
	"\n	 //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n	 // 4) Se a a็ใo for empilhar...."
	"\n	 //จจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจจ"
	"\n	 } else {"
	"\n	     pilhaEstados.push(acaoAnalisador - 2000);"
	"\n"
	"\n         // Pede um novo token ao analisador l้xico"
	"\n         tokenCorrente = lex.proxToken();"
	"\n"
	"\n         // Se foi gerado um erro lexico, guarda a mensagem de erro"
	"\n         if ( lex.encontrouErro() ) {"
	"\n             msgErro = lex.getMsgErro();"
	"\n             break;"
	"\n         }"
	"\n"
	"\n  	 // Se nใo foi gerado um erro l้xico, guarda o atributo do token, se ele tiver"
	"\n	 if(TabelaAnalisadorSintatico::isTermAtrib(tokenCorrente.getValor()-1) == TRUE)  {"
	"\n 	        listaAtributos.push_back( tokenCorrente.getAtributo() );"
	"\n     }"
	"\n	}"
	"\n  }"
	"\n"
	"\n  // Se anแlise sintแtica ocorreu com sucesso, prepara a pilha de producoes para"
	"\n  // que seja utilizada pelo analisador semโntico"
	"\n  if( acaoAnalisador == ACAO_ACEITAR && pilhaProducoesBottomUp.size() > 0 ) {"
	"\n      int topo = pilhaProducoesBottomUp.top();"
	"\n      pilhaProducoesBottomUp.pop();"
	"\n      transforma_producoes_analisador_semantico( topo );"
	"\n  }"
	"\n }"
	"\n"
	"\n"
	"\n //----------------------------------------------------------------------------------"
	"\n // M้todo que, dado um estado e um nใo terminal, retorna o estado correspondente"
	"\n // na entrada da tabela sintแtica desvio(estado,nใo-terminal)"
	"\n // A tabela ้ representada pelo vetor vet_goto"
	"\n//----------------------------------------------------------------------------------"
	"\n int AnalisadorSintatico::determina_desvio(int &estado,int &nao_terminal) {"
	"\n 	int numElementosVetor = TabelaAnalisadorSintatico::getNumeroLinhasTabelaGoto() ;"
	"\n 	for( int i=0; i< numElementosVetor; i++ ) {"
	"\n 		if( (TabelaAnalisadorSintatico::getGoto(i,0) == estado) && (TabelaAnalisadorSintatico::getGoto(i,1) == nao_terminal) ) {"
	"\n 		   return TabelaAnalisadorSintatico::getGoto(i,2) ;"
	"\n 		}"
	"\n 	}"
	"\n 	return -1 ;"
	"\n }"
	"\n"
	"\n //------------------------------------------------------------------------------"
	"\n // Transforma a pilha de producoes que estแ no formato bottom-up para top-down"
	"\n //------------------------------------------------------------------------------"
	"\n void AnalisadorSintatico::transforma_producoes_analisador_semantico(int topo) {"
	"\n"
	"\n   for (int i=1; i <= TabelaAnalisadorSintatico::getNtFilhos(topo -1); i++) {"
	"\n      int topo = pilhaProducoesBottomUp.top();"
	"\n      pilhaProducoesBottomUp.pop();"
	"\n      transforma_producoes_analisador_semantico( topo );"
	"\n   }"
	"\n"
	"\n   int nao_terminal = TabelaAnalisadorSintatico::getNTermEsquerda(topo-1);"
	"\n"
	"\n   // So empilha reducao de nao terminal com mais de uma producao associada"
	"\n   if(TabelaAnalisadorSintatico::getProducoesAssociadas(nao_terminal - 1) > 1) {"
	"\n       pilhaProducoesTopDown.push(topo);"
	"\n   }"
	"\n }"
	"\n"
	"\n //------------------------------------------------------------------------------"
	"\n // M้todo utilitแrios, para limpar as estruras de dados"
	"\n //------------------------------------------------------------------------------"
	"\n void AnalisadorSintatico::limpaVariaveis() {"
	"\n	 this->listaAtributos.clear();"
	"\n	 while(this->pilhaProducoesTopDown.size() > 0) this->pilhaProducoesTopDown.pop() ;"
	"\n	 while( this->pilhaProducoesBottomUp.size() > 0 ) this->pilhaProducoesBottomUp.pop() ;"
	"\n	 this->msgErro = \"\" ;"
	"\n }"
	"\n"
	"\n"
	"\n //------------------------------------------------------------------------------"
	"\n // Funcใo que trata erro"
	"\n //------------------------------------------------------------------------------"
	"\n void AnalisadorSintatico::trata_erro(int &tipo,int &estado, Token tokenCorrente) {"
	"\n	char cadeia[30];"
	"\n	itoa( tokenCorrente.getValor(), cadeia, 10 );"
	"\n   this->msgErro = \"Token nใo esperado: \" + std::string(cadeia) ;"
	"\n }"
	"\n"
	;
	fputs(fonte.c_str(), arq_c);

	// Fecha arquivos
    if (fclose(arq_c)==EOF) Mensagem::falha(FECHAMENTO_ARQ,nome_sin_c);
    if (fclose(arq_h)==EOF) Mensagem::falha(FECHAMENTO_ARQ,nome_sin_h);
}

#endif
